function net=TrainRN(x,inputs, targets,u,a)
     % Solve a Pattern Recognition Problem with a Neural Network
    % Script generated by Neural Pattern Recognition app
    % Created 10-Dec-2017 21:50:43
    %
    % This script assumes these variables are defined:
    %
    %   MatrizImput - input data.
    %   Etiquetas - target data.
    tam=size(x);
    %display(tam(2));
    %display(x);
    auxBinary=x(1:3);
    firstLayer =bi2de(auxBinary());
    auxBinary=x(4:6);
    secondLayer=bi2de(auxBinary());
    firstLayer=5+5*firstLayer;
    secondLayer=5*secondLayer;
    %display(firstLayer);
    %display(secondLayer);
    cont=1;
    Datos=[];
    for k=7:tam(2)
        if(x(k)==1)
            Datos=horzcat(Datos,inputs(:,cont)) ;
        end
        cont=cont+1;
    end
    %display(Datos);
    inputs = Datos';
    targets = targets';

    % Choose a Training Function
    %{trainlm,trainbr,trainscg,traincgf,traingdm}
    trainFcn = 'trainscg'; 

    % Create a Pattern Recognition Network

    if(secondLayer>0)
        net = patternnet([firstLayer,secondLayer],trainFcn);
        %transferFcn = {tansig,purelin,compet}
        net.layers{1}.transferFcn = 'tansig';
        net.layers{2}.transferFcn = 'tansig';
        net.layers{3}.transferFcn = 'purelin';
    else
        net = patternnet(firstLayer,trainFcn);
        net.layers{1}.transferFcn = 'tansig';
        net.layers{2}.transferFcn = 'purelin';
    end;
    % Choose Input and Output Pre/Post-Processing Functions
    % For a list of all processing functions type: help nnprocess
    net.input.processFcns = {'removeconstantrows','mapminmax'};
    net.output.processFcns = {'removeconstantrows','mapminmax'};
    net.trainParam.lr=u;
    net.trainParam.mc=a;
    % Setup Division of Data for Training, Validation, Testing
    % For a list of all data division functions type: help nndivide
    net.divideFcn = 'dividerand';  
    net.divideMode = 'sample';  
    net.divideParam.trainRatio = 70/100;
    net.divideParam.valRatio = 15/100;
    net.divideParam.testRatio = 15/100;
    
    % Choose a Performance Function
    % For a list of all performance functions type: help nnperformance
    %{mse,crossentropy}
    net.performFcn = 'mse';  

    % Choose Plot Functions
    % For a list of all plot functions type: help nnplot
    net.plotFcns = {'plotperform','plottrainstate','ploterrhist', ...
        'plotconfusion', 'plotroc'};
    performance=0;
    FSMC=0;
    Sensitivity=0;
    Specificity=0;
    Accuracy=0;
    CCR=0;
    
    for i=1:10
        display('------');
        % Train the Network
        [net,tr] = train(net,inputs,targets);
        % Test the Network
        y = net(inputs);
        [c,cm,ind,per] = confusion(targets,y);
        %display('******');
        TP=cm(1)
        FP=cm(2)
        FN=cm(3)
        TN=cm(4)

        e = gsubtract(targets,y);
        performance = (perform(net,targets,y))+performance;
        tind = vec2ind(targets);
        yind = vec2ind(y);
        percentErrors = sum(tind ~= yind)/numel(tind);

        % Recalculate Training, Validation and Test Performance
        trainTargets = targets .* tr.trainMask{1};
        valTargets = targets .* tr.valMask{1};
        testTargets = targets .* tr.testMask{1};
        trainPerformance = perform(net,trainTargets,y);
        valPerformance = perform(net,valTargets,y);
        testPerformance = perform(net,testTargets,y);
        FSMC=((FN+FP)/(TP+FN+TN+FP))+FSMC;
        Sensitivity=((TP)/(TP+FN))+Sensitivity;
        Specificity =((TN)/(TN+FP))+Specificity;
        Accuracy=((TP)/(TP+FP))+Accuracy;
        CCR=((TP+TN)/(TP+FP+TN+FN))+CCR;
        % View the Network
        view(net)

        % Plots
        % Uncomment these lines to enable various plots.
        %figure, plotperform(tr)
        %figure, plottrainstate(tr)
        %figure, ploterrhist(e)
        %figure, plotconfusion(t,y)
        %figure, plotroc(t,y)
    end
    performance=performance/10
    FSMC=FSMC/10
    Specificity=Specificity/10
    Sensitivity=Sensitivity/10
    Accuracy=Accuracy/10
    CCR=CCR/10
end